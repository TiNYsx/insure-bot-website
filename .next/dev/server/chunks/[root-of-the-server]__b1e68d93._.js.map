{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tinysx/Documents/GitHub/insure-bot-website/app/api/proxy/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\r\n\r\n// Simple proxy to forward client requests to an external webhook.\r\n// The client should POST JSON with fields:\r\n// - webhookUrl: string (required)\r\n// - message, messages (optional) for JSON payloads\r\n// - audioBase64, audioFilename (optional) for audio uploads (base64 string)\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json()\r\n    const { webhookUrl, message, messages, audioBase64, audioFilename } = body\r\n\r\n    if (!webhookUrl || typeof webhookUrl !== 'string') {\r\n      return new Response(JSON.stringify({ error: 'Missing webhookUrl' }), { status: 400 })\r\n    }\r\n\r\n    const controller = new AbortController()\r\n    // Mirror the client timeout (5 minutes)\r\n    const timeout = setTimeout(() => controller.abort(), 300000)\r\n\r\n    let forwardRes: Response\r\n\r\n    if (audioBase64) {\r\n      // Construct FormData with a binary audio file and messages\r\n      const formData = new FormData()\r\n      // Convert base64 to Uint8Array\r\n      const buffer = Buffer.from(audioBase64, 'base64')\r\n      const blob = new Blob([buffer], { type: 'audio/wav' })\r\n      formData.append('audio', blob, audioFilename || 'audio.wav')\r\n      formData.append('messages', JSON.stringify(messages || []))\r\n\r\n      forwardRes = await fetch(webhookUrl, {\r\n        method: 'POST',\r\n        body: formData,\r\n        signal: controller.signal,\r\n      })\r\n    } else {\r\n      // Forward as JSON\r\n      forwardRes = await fetch(webhookUrl, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ message, messages }),\r\n        signal: controller.signal,\r\n      })\r\n    }\r\n\r\n    clearTimeout(timeout)\r\n\r\n    const contentType = forwardRes.headers.get('content-type') || 'text/plain'\r\n    const payload = await forwardRes.arrayBuffer()\r\n\r\n    return new Response(payload, {\r\n      status: forwardRes.status,\r\n      headers: { 'content-type': contentType },\r\n    })\r\n  } catch (err: any) {\r\n    console.error('Proxy error:', err)\r\n    if (err.name === 'AbortError') {\r\n      return new Response(JSON.stringify({ error: 'Upstream request timed out' }), { status: 504 })\r\n    }\r\n    return new Response(JSON.stringify({ error: 'Proxy failed', details: String(err) }), { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAQO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG;QAEtE,IAAI,CAAC,cAAc,OAAO,eAAe,UAAU;YACjD,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;gBAAE,OAAO;YAAqB,IAAI;gBAAE,QAAQ;YAAI;QACrF;QAEA,MAAM,aAAa,IAAI;QACvB,wCAAwC;QACxC,MAAM,UAAU,WAAW,IAAM,WAAW,KAAK,IAAI;QAErD,IAAI;QAEJ,IAAI,aAAa;YACf,2DAA2D;YAC3D,MAAM,WAAW,IAAI;YACrB,+BAA+B;YAC/B,MAAM,SAAS,OAAO,IAAI,CAAC,aAAa;YACxC,MAAM,OAAO,IAAI,KAAK;gBAAC;aAAO,EAAE;gBAAE,MAAM;YAAY;YACpD,SAAS,MAAM,CAAC,SAAS,MAAM,iBAAiB;YAChD,SAAS,MAAM,CAAC,YAAY,KAAK,SAAS,CAAC,YAAY,EAAE;YAEzD,aAAa,MAAM,MAAM,YAAY;gBACnC,QAAQ;gBACR,MAAM;gBACN,QAAQ,WAAW,MAAM;YAC3B;QACF,OAAO;YACL,kBAAkB;YAClB,aAAa,MAAM,MAAM,YAAY;gBACnC,QAAQ;gBACR,SAAS;oBAAE,gBAAgB;gBAAmB;gBAC9C,MAAM,KAAK,SAAS,CAAC;oBAAE;oBAAS;gBAAS;gBACzC,QAAQ,WAAW,MAAM;YAC3B;QACF;QAEA,aAAa;QAEb,MAAM,cAAc,WAAW,OAAO,CAAC,GAAG,CAAC,mBAAmB;QAC9D,MAAM,UAAU,MAAM,WAAW,WAAW;QAE5C,OAAO,IAAI,SAAS,SAAS;YAC3B,QAAQ,WAAW,MAAM;YACzB,SAAS;gBAAE,gBAAgB;YAAY;QACzC;IACF,EAAE,OAAO,KAAU;QACjB,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,IAAI,IAAI,IAAI,KAAK,cAAc;YAC7B,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;gBAAE,OAAO;YAA6B,IAAI;gBAAE,QAAQ;YAAI;QAC7F;QACA,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;YAAE,OAAO;YAAgB,SAAS,OAAO;QAAK,IAAI;YAAE,QAAQ;QAAI;IACrG;AACF"}}]
}